# action.yml

name: "Deployment Action"
description: "An action to deploy next/js servers to my self-hosted server."

inputs:
  api-host:
    description: "The hostname of the API server."
    required: true
  api-secret:
    description: "The secret token for API authentication."
    required: true
  commit-sha:
    description: "The SHA for the commit."
    required: true
  app-name:
    description: "The name of the app, e.g. 'george-wild/deploy-action'."
    required: true

runs:
  using: "composite"
  steps:
    - name: Setup
      shell: bash
      run: |
        sudo apt update
        sudo apt install -y jq

    - name: Trigger Deployment API
      id: trigger_deploy
      shell: bash
      run: |
        API_URL="https://${{ inputs.api-host }}/deploy"
         
        echo "Attempting to trigger deployment via POST ${API_URL}"
         
        # Send the POST request to trigger the deployment
        RESPONSE=$(curl -s -X POST "${API_URL}" \
          -H "X-Deploy-Token: ${{ inputs.api-secret }}" \
          -H "Content-Type: application/json" \
          -d '{
            "appName": "${{ inputs.app-name }}",
            "commitSha": "${{ inputs.commit-sha }}"
            # --- REMOVED: buildDir from the JSON payload ---
          }')

        echo $RESPONSE
        # Check for HTTP errors first
        if [[ $? -ne 0 ]]; then
            echo "::error::Curl command failed to connect to the server API."
            exit 1
        fi

        # Check for server-side errors (e.g., 400, 429) and extract deployment ID
        ERROR_MESSAGE=$(echo $RESPONSE | jq -r '.error')
        DEPLOYMENT_ID=$(echo $RESPONSE | jq -r '.deploymentId')

        if [ "$ERROR_MESSAGE" != "null" ]; then
            echo "::error::Deployment trigger failed on server: $ERROR_MESSAGE"
            echo "Server Response: $RESPONSE"
            exit 1
        fi

        if [ "$DEPLOYMENT_ID" == "null" ] || [ "$DEPLOYMENT_ID" == "" ]; then
            echo "::error::Deployment ID not returned from server. Trigger failed."
            echo "Server Response: $RESPONSE"
            exit 1
        fi

        echo "Deployment ID: $DEPLOYMENT_ID"
        # Pass the Deployment ID to the next step
        echo "deploymentId=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

    - name: Poll Status and Stream Logs
      shell: bash
      id: poll_logs
      run: |
        # Retrieve the deployment ID from the previous step's output
        DEPLOYMENT_ID="${{ steps.trigger_deploy.outputs.deploymentId }}"
        STATUS_URL="http://${{ inputs.api-host }}:${{ inputs.api-port }}/status/${DEPLOYMENT_ID}"
        DEPLOY_STATUS="RUNNING"
        LOG_INDEX=0 # Track which logs have already been printed

        echo "Starting log stream for Deployment ID: $DEPLOYMENT_ID. Polling every 5 seconds."

        while [ "$DEPLOY_STATUS" == "RUNNING" ]; do
          sleep 5 # Poll every 5 seconds
          
          # Use curl to get the latest status
          RESPONSE=$(curl -s -X GET "${STATUS_URL}" \
            -H "X-Secret: ${{ inputs.api-secret }}")
            
          # Safely parse status and logs using jq
          DEPLOY_STATUS=$(echo $RESPONSE | jq -r '.status')
          LOGS=$(echo $RESPONSE | jq -r '.logs[]')
          
          # Check if the server returned a valid status
          if [ "$DEPLOY_STATUS" == "null" ]; then
              echo "::error::Polling failed: Could not parse status from server response."
              echo "Last Response: $RESPONSE"
              exit 1
          fi

          # --- Log Streaming Logic ---
          NEW_LOGS=0
          # The logs are streamed one line at a time to the GitHub Action console
          while IFS= read -r LINE; do
            if [ $NEW_LOGS -ge $LOG_INDEX ]; then
              # Look for the stage indicator [STAGE:...] created by your server API
              if [[ $LINE =~ ^\[STAGE:(.*?)\] ]]; then
                 STAGE="${BASH_REMATCH[1]}"
                 # Print a recognizable heading for the GitHub UI
                 echo "## ⚙️ Deployment Stage: $STAGE"
                 echo "$LINE"
              else
                 echo "$LINE"
              fi
            fi
            NEW_LOGS=$((NEW_LOGS + 1))
          done <<< "$LOGS"

          LOG_INDEX=$NEW_LOGS
          # --- End Log Streaming Logic ---
          
          if [ "$DEPLOY_STATUS" == "SUCCESS" ]; then
            echo "✅ Deployment finished successfully on the server."
            exit 0 # Success
          elif [ "$DEPLOY_STATUS" == "FAILURE" ]; then
            echo "❌ Deployment FAILED on the server. Review logs above for failure details."
            exit 1 # Fail the GitHub Action
          fi
        done
